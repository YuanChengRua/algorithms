# In python, the implementation of hashmap is dict() and the time complexity is O(1)
# hashmap can be used to check if the value is already in the dict, if the value not in the dict, the value will be added otherwise, it will be ignored

voted = {}

def check_vote(name):
    if voted.get(name) == True:
        print("Kcik them out")
    else:
        voted[name] = True
        print("Let them vote")

# note, for some websites, they use cache to store some common content like sign in page, about, term and condition so the backend don't need to
# generate those pages and the website will directly reach the cached pages and these cached pages are saved by hashmap

cache = {}
def get_page(url):
    if cache.get(url) == True:
        return cache[url]
    else:
        cache[url] = True # usually not True but the data generated by the server
        # return data

# The conflict could happen when several values share the same key and for the conflicted keys, they will use link list to combine the conflicted values
# When the most values conflict in one key, the link list will be very long which could make the searching time very long.

# To avoid conflict, we need to reduce the ratio: number of values / number of keys. When we input more and more values in the hashmap, the ratio will increase
# so we can extend the number of keys to remain the ratio less than 0.7